package main

import (
	"fmt"
	"log"
	"path/filepath"
	"strings"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/app"
	"fyne.io/fyne/v2/canvas"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/layout"
	"fyne.io/fyne/v2/theme"
	"fyne.io/fyne/v2/widget"

	"github.com/latreon/file-compressor/pkg/archiver"
)

// UI state variables
type appState struct {
	sourcePath      string
	destinationPath string
	format          string
	compressing     bool
	progressChan    chan float64
}

func main() {
	// Initialize application
	a := app.New()
	w := a.NewWindow("File Compressor")
	w.Resize(fyne.NewSize(800, 600))

	// Initialize application state
	state := &appState{
		format:       "zip",
		progressChan: make(chan float64),
	}

	// Create UI components
	logoImage := canvas.NewImageFromFile("assets/logo.png")
	if logoImage.Resource == nil {
		// If logo file is not found, create a placeholder
		logoImage = canvas.NewImageFromResource(theme.FileApplicationIcon())
	}
	logoImage.FillMode = canvas.ImageFillContain
	logoImage.SetMinSize(fyne.NewSize(100, 100))

	title := widget.NewLabel("Advanced File Compressor")
	title.TextStyle = fyne.TextStyle{Bold: true}
	title.Alignment = fyne.TextAlignCenter

	// Source file/folder selection
	sourceLabel := widget.NewLabel("Source:")
	sourceEntry := widget.NewEntry()
	sourceEntry.Disable()

	// Destination file selection - declare before sourceButton to resolve the reference issue
	destLabel := widget.NewLabel("Destination:")
	destEntry := widget.NewEntry()
	destEntry.Disable()

	sourceButton := widget.NewButton("Browse", func() {
		fd := dialog.NewFileOpen(func(reader fyne.URIReadCloser, err error) {
			if err != nil || reader == nil {
				return
			}
			path := reader.URI().Path()
			reader.Close()
			state.sourcePath = path
			sourceEntry.SetText(path)

			// Auto-generate destination path
			autoGenerateDestPath(state, path, destEntry)
		}, w)
		fd.Show()
	})

	destButton := widget.NewButton("Browse", func() {
		fd := dialog.NewFileSave(func(writer fyne.URIWriteCloser, err error) {
			if err != nil || writer == nil {
				return
			}
			path := writer.URI().Path()
			writer.Close()
			state.destinationPath = path
			destEntry.SetText(path)
		}, w)
		fd.Show()
	})

	// Format selection
	formatLabel := widget.NewLabel("Compression Format:")
	formatSelect := widget.NewSelect([]string{"zip", "tar", "gz", "bz2", "xz"}, func(value string) {
		state.format = value

		// Update destination extension if we have a source
		if state.sourcePath != "" {
			autoGenerateDestPath(state, state.sourcePath, destEntry)
		}
	})
	formatSelect.SetSelected("zip")

	// Drop area with instructions
	dropLabel := widget.NewLabelWithStyle(
		"Drag and drop files or folders here",
		fyne.TextAlignCenter,
		fyne.TextStyle{Italic: true},
	)

	dropIcon := widget.NewIcon(theme.FolderOpenIcon())
	dropIcon.Resize(fyne.NewSize(48, 48))

	dropArea := container.NewVBox(
		layout.NewSpacer(),
		container.NewCenter(dropIcon),
		container.NewCenter(dropLabel),
		layout.NewSpacer(),
	)

	// Wrap in a card for visual appeal
	dropZone := widget.NewCard("", "", dropArea)
	dropZone.Resize(fyne.NewSize(300, 200))

	// Progress bar
	progress := widget.NewProgressBar()
	progressLabel := widget.NewLabel("Ready")
	progressLabel.Alignment = fyne.TextAlignCenter

	// Action buttons
	compressButton := widget.NewButton("Compress", func() {
		if state.compressing {
			return
		}
		if state.sourcePath == "" {
			dialog.ShowError(fmt.Errorf("no source file/folder selected"), w)
			return
		}
		if state.destinationPath == "" {
			dialog.ShowError(fmt.Errorf("no destination file selected"), w)
			return
		}

		// Start compression in a goroutine
		go startCompression(state, progressLabel, progress, w)
	})
	compressButton.Importance = widget.HighImportance

	extractButton := widget.NewButton("Extract", func() {
		if state.compressing {
			return
		}
		if state.sourcePath == "" {
			dialog.ShowError(fmt.Errorf("no archive file selected"), w)
			return
		}
		if state.destinationPath == "" {
			dialog.ShowError(fmt.Errorf("no destination folder selected"), w)
			return
		}

		// Start extraction in a goroutine
		go startExtraction(state, progressLabel, progress, w)
	})
	extractButton.Importance = widget.HighImportance

	// Setup file drop handling
	w.Canvas().SetOnTypedKey(func(ke *fyne.KeyEvent) {
		// This is a placeholder, we're only interested in file drops
	})

	w.SetOnDropped(func(pos fyne.Position, files []fyne.URI) {
		if len(files) == 0 {
			return
		}

		// Get the first dropped URI
		uri := files[0]
		path := uri.Path()
		state.sourcePath = path
		sourceEntry.SetText(path)

		// Auto-generate destination path
		autoGenerateDestPath(state, path, destEntry)

		// Update the drop zone visual
		dropIcon.SetResource(theme.DocumentIcon())
		dropLabel.SetText(filepath.Base(path))
	})

	// Monitor progress updates in a separate goroutine
	go func() {
		for p := range state.progressChan {
			progress.SetValue(p)
		}
	}()

	// Layout the UI
	headerContent := container.NewVBox(
		container.NewCenter(logoImage),
		container.NewCenter(title),
	)

	formContent := container.NewVBox(
		container.New(layout.NewFormLayout(), sourceLabel, container.NewBorder(nil, nil, nil, sourceButton, sourceEntry)),
		container.New(layout.NewFormLayout(), destLabel, container.NewBorder(nil, nil, nil, destButton, destEntry)),
		container.New(layout.NewFormLayout(), formatLabel, formatSelect),
	)

	// Action buttons in a horizontal container
	actionButtons := container.NewHBox(
		layout.NewSpacer(),
		compressButton,
		extractButton,
		layout.NewSpacer(),
	)

	mainContent := container.NewVBox(
		headerContent,
		dropZone,
		formContent,
		container.NewVBox(
			progress,
			progressLabel,
			actionButtons,
		),
	)

	// Set main content
	w.SetContent(container.NewPadded(mainContent))
	w.ShowAndRun()
}

// autoGenerateDestPath generates a destination path based on the source path
func autoGenerateDestPath(state *appState, sourcePath string, destEntry *widget.Entry) {
	// Check if the source is an archive (for extraction)
	ext := strings.ToLower(filepath.Ext(sourcePath))
	if ext == ".zip" || ext == ".tar" || ext == ".gz" || ext == ".bz2" || ext == ".xz" {
		// For extraction, set destination to a folder with the same name without extension
		baseName := filepath.Base(sourcePath)
		baseName = baseName[:len(baseName)-len(ext)]
		destPath := filepath.Join(filepath.Dir(sourcePath), baseName+"-extracted")
		state.destinationPath = destPath
		destEntry.SetText(destPath)
	} else {
		// For compression, add the format extension
		ext := "." + state.format
		if !strings.HasSuffix(sourcePath, ext) {
			baseName := filepath.Base(sourcePath)
			destPath := filepath.Join(filepath.Dir(sourcePath), baseName+ext)
			state.destinationPath = destPath
			destEntry.SetText(destPath)
		}
	}
}

// startCompression handles the compression process
func startCompression(state *appState, progressLabel *widget.Label, progressBar *widget.ProgressBar, window fyne.Window) {
	state.compressing = true
	progressLabel.SetText("Compressing...")
	progressBar.SetValue(0)

	// Create a custom progress writer that can update the UI
	originalProgressWriter := archiver.NewProgressCallback(
		func(bytesWritten, totalSize int64) {
			if totalSize > 0 {
				// Calculate the percentage
				percentage := float64(bytesWritten) / float64(totalSize)
				// Send progress update
				state.progressChan <- percentage
			}
		},
	)

	// Start compression
	err := archiver.CompressWithProgress(state.sourcePath, state.destinationPath, state.format, originalProgressWriter)

	// Update UI based on compression result
	if err != nil {
		log.Printf("Compression error: %v", err)
		progressLabel.SetText(fmt.Sprintf("Error: %v", err))
		dialog.ShowError(err, window)
	} else {
		progressLabel.SetText("Compression Completed Successfully!")
		progressBar.SetValue(1.0)

		// Show success dialog
		dialog.ShowInformation("Success",
			fmt.Sprintf("File successfully compressed to:\n%s", state.destinationPath),
			window)
	}

	state.compressing = false
}

// startExtraction handles the extraction process
func startExtraction(state *appState, progressLabel *widget.Label, progressBar *widget.ProgressBar, window fyne.Window) {
	state.compressing = true
	progressLabel.SetText("Extracting...")
	progressBar.SetValue(0)

	// Create a custom progress tracker that can update the UI
	progressTracker := archiver.NewProgressCallback(
		func(bytesWritten, totalSize int64) {
			if totalSize > 0 {
				// Calculate the percentage
				percentage := float64(bytesWritten) / float64(totalSize)
				// Send progress update
				state.progressChan <- percentage
			}
		},
	)

	// Start extraction
	err := archiver.ExtractWithProgress(state.sourcePath, state.destinationPath, progressTracker)

	// Update UI based on extraction result
	if err != nil {
		log.Printf("Extraction error: %v", err)
		progressLabel.SetText(fmt.Sprintf("Error: %v", err))
		dialog.ShowError(err, window)
	} else {
		progressLabel.SetText("Extraction Completed Successfully!")
		progressBar.SetValue(1.0)

		// Show success dialog
		dialog.ShowInformation("Success",
			fmt.Sprintf("Archive successfully extracted to:\n%s", state.destinationPath),
			window)
	}

	state.compressing = false
}
